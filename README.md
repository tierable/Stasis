# Stasis
Stasis is a general purpose library to persist state using annotation processing and code generation.


## The (Android) problem
Android user interface classes (`Activity`s, `Fragment`s, etc) provide a (limited) mechanism to save important bits of the UI state (the `onSavedInstanceState(Bundle)` and `onRestoreInstanceState(Bundle)` mechanism).
However, in practice this is not comprehensive enough to fully restore the UI.
There's flags that aren't commonly known by developers (like `freezesText` for `TextView`s), data that can't normally be accessed, or other things that can't be stored properly in a `Bundle` (like adapters, etc).

Stasis provides an Android specialisation with sensible defaults for UI state preservation.


## Usage
Stasis uses a similar approach to [Jake Wharton's ButterKnife](https://github.com/JakeWharton/butterknife) library. 
In a class you'd like to preserve, just annotate the relevant fields with the `@StasisPreserve` annotation and the annotation processor generates a `StasisPreservationStrategy` for your class.

### Dependencies
TODO: coming soon!

### Providing a mapping class
Provide a *single* interface (for now?) in your module and mark it with the `@StasisPreservationMapping` annotation.
You can define a fallback strategy if you don't want to define a mapping for every type of preserved class.
The default fallback strategy is to not save anything.

The mapping interface can extend other interfaces.
Methods in the interface:
* Can be named whatever you desire (as long as it makes sense). 
The `getStrategy` name has been used in examples as an appropriate name though
* Must return a `StatisPreservationStrategy`
* Can have more than one parameter if you need the same `StatisPreservationStrategy` for multiple types

```Java
// Uses the marker annotation
@StasisPreservationMapping(MyFallbackPreservationStrategy.class)
public interface DemoMapping 
	extends AnotherMapping, YetAnotherMapping {
	// Multiple mappings for a StasisPreservationStrategy
	StasisPreservationStrategyButton getStrategy(Button button, ButtonChildClass buttonChildClass);

	// Single mapping for a StasisPreservationStrategy
	StasisPreservationStrategyTextField getStrategy(TextField textField);

	// etc
}
```

### Creating custom preservation strategies
Just create a class implementing the `StasisPreservationStrategy` interface or extending a pre-existing `StasisPreservationStrategy`.
The only limitation is that you can only use the default (no argument) constructor for generated code.


### Preserving state
Stasis generates a `StasisPreservationStrategy` implementation for every class with atleast one member annotated with `@StasisPreserve`.
The generated class names will be in the format `StasisPreservationStrategy[YourClassNameHere]` and will be outputted to the same package.
Preserved fields must be either public or package private so they are accessible by the generated code.


```Java

public class DemoClass {

	@StasisPreserve
	Button buttonWithADefaultPreservationStrategy;

	@StasisPreserve(value = MyCustomButtonPreservationStrategy.class)
	Button buttonWithACustomPreservationStrategy;

	@StasisPreserve(enabled = false)
	Button buttonWithPreservationDisabled;

	Button buttonNotPreserved;

	// Generated by Stasis
	private StasisPreservationStrategyDemoClass preservationStrategy;
	
	
	public void initialise() {
		preservationStrategy = new StasisPreservationStrategyDemoClass();
	}
	
	public void saveState() {
		// 'Freeze'/'save' this classes state
		preservationStrategy.freeze(this);
		
		// TODO: save the preservationStrategy somewhere
	}
	
	public void restoreState() {
		// TODO: Restore the preservationStrategy from somewhere
		
		// 'UnFreeze'/'restore' this classes state
		preservationStrategy.unFreeze(this);
	}
	
	// etc
}
```
